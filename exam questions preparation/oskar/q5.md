
## Question
Memory Management: Memory management is handled differently in Rust compared to 
other languages like C++, C# or Java. Describe how Rustâ€™s memory management 
principles affected the way you structured your project. Include examples of how you used Box, Rc, or RefCell in managing heap data.

## Code Snippet:

ui/mod.rs - The use of Box.
```rust
pub fn build_ui() -> impl druid::Widget<AppState> {
    ViewSwitcher::new(
        |data: &AppState, _env| (data.current_screen.clone(), data.game_number.clone()),
        |(screen, _game_number), _data, _env| -> Box<dyn druid::Widget<AppState>> {
            fn with_navbar(inner: impl Widget<AppState> + 'static) -> impl Widget<AppState> {
                Flex::column()
                    .with_child(build_navbar())
                    .with_spacer(10.0)
                    .with_flex_child(inner, 1.0)
            }

            match screen {
                Screen::Loading => Box::new(loading_screen::build_screen()),
                Screen::Main => Box::new(main_screen::build_screen()),
                Screen::TeamScreen { team_id } => {
                    Box::new(with_navbar(team_screen::build_screen(team_id)))
                }
                Screen::ChooseTeam => Box::new(choose_team_screen::build_screen()),
                Screen::MainGameScreen => Box::new(with_navbar(main_game_screen::build_screen())),
                Screen::RaceScreen { race_id } => {
                    Box::new(with_navbar(race_screen::build_screen(*race_id)))
                }
                
            [...]
```

ui/driver_screen.rs
```rust
pub fn build_screen(driver_id: &u16) -> impl Widget<AppState> {
    let driver = get_driver_by_id(driver_id).unwrap();
    let driver_contract = get_driver_contract(driver_id).unwrap();

    let mut right_column = Flex::column().cross_axis_alignment(CrossAxisAlignment::Start);
    right_column.add_child(get_driver(driver.image_path.as_str()));
    right_column.add_child(get_country(
        &get_country_image_path(&driver.country_id).unwrap(),
    ));
    right_column.add_spacer(10.0);
    right_column.add_child(Label::new(format!("Overall Rating:\t{}", driver.rating)));
    right_column.add_child(Label::new(format!(
        "Date of Birth:\t\t{}",
        driver.date_of_birth
    )));
    right_column.add_child(Label::new(format!(
        "Racing Number:\t{}",
        driver.racing_number
    )));
```



database/driver.rs
```rust
pub fn get_driver_id_by_fullname(full_name: &str) -> Option<u16> {
    let conn = get_connection().unwrap();
    let mut stmt = conn
        .prepare("SELECT id FROM drivers WHERE first_name || ' ' || last_name = ?")
        .unwrap();
    let row = stmt.query_row([full_name], |row| row.get(0));
    match row {
        Ok(id) => Some(id),
        Err(_) => None,
    }
}
```


ui/mod.rs
```rust
fn build_navbar() -> impl Widget<AppState> {
    let home_button = Button::new("Home").on_click(|ctx, data: &mut AppState, _env| {
        data.current_screen = MainGameScreen;
        ctx.request_update();
    });
```
main.rs
```rust
fn main() -> Result<(), PlatformError> {
    let main_window = WindowDesc::new(ui::build_ui()).title("Formula One Manager");
    AppLauncher::with_window(main_window)
        .delegate(MyAppDelegate::new())
        .launch(AppState::default())
        .expect("Failed to launch application");

    Ok(())
}
```