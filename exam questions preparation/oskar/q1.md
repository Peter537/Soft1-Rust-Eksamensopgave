
## Question
Error Handling and Enums: How have you used enums to manage errors in your project? Discuss any patterns you implemented, such as the Result or Option types, and how they contributed to your applicationâ€™s robustness (Option data type [ Some() and None()] and the Result type [OK() or Err()]) 

## Code Snippet:

circuit.rs
```rust
use crate::database::connection::get_connection;
use crate::model::Circuit;

pub fn get_circuit_by_id(circuit_id: &u16) -> Option<Circuit> {
    let conn = get_connection().unwrap();
    let mut stmt = conn.prepare(
        "SELECT name, fk_country_id, city, length_km, lap_amount, image_circuit FROM circuits WHERE id = ?"
    ).unwrap();
    let row = stmt.query_row([circuit_id], |row| {
        Ok(Circuit {
            name: row.get(0)?,
            country_id: row.get(1)?,
            city: row.get(2)?,
            length_km: row.get(3)?,
            lap_amount: row.get(4)?,
            image_path: row.get(5)?,
        })
    });
    match row {
        Ok(circuit) => Some(circuit),
        Err(_) => None,
    }
}

```

circuit.rs is used race_screen.rs

race_screen.rs
```rust
pub fn build_screen(race_id: u16) -> impl Widget<AppState> {
    let circuit_data = get_circuit_by_id(&race_id).unwrap();
```

util/file.rs
```rust
pub fn download_file(url: &str, dest: &PathBuf) -> Result<(), Box<dyn Error + Send>> {
    let mut response = get(url).map_err(|e| Box::new(e) as Box<dyn Error + Send>)?;
    let mut file = File::create(dest).map_err(|e| Box::new(e) as Box<dyn Error + Send>)?;
    copy(&mut response, &mut file).map_err(|e| Box::new(e) as Box<dyn Error + Send>)?;
    Ok(())
}
```



bottom of `choose_team_screen.rs` we use if let Some() 
```rust
let selected_team_label = Label::<AppState>::new(|data: &AppState, _env: &Env| {
        if let Some(ref team) = data.selected_team {
            team.to_string()
        } else {
            "No team selected".to_string()
        }
    })
    .with_text_size(16.0);
```



util/image_loader.rs
Other handling:
```rust
fn get_image_at(path: PathBuf) -> Box<dyn Widget<AppState>> {
    let image_path = get_mod_default_path().join(path);
    if !image_path.exists() {
        return Box::new(Label::new("Image not found").with_text_color(Color::RED));
    }

    let dyn_image = open(image_path).expect("Failed to open image");
    let rgba_image = dyn_image.to_rgba8();
    let (width, height) = rgba_image.dimensions();

    let image_buf = ImageBuf::from_raw(
        rgba_image.into_raw(),
        ImageFormat::RgbaSeparate,
        width as usize,
        height as usize,
    );

    Box::new(Image::new(image_buf).fix_size(200.0, 200.0))
}
```	