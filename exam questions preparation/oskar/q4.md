
## Question
Polymorphism: Traits and Enums in Rust allow for polymorphism. Can you discuss a place in your project where you implemented polymorphic behavior? How did this design choice benefit your project? How is the problem of inheritance avoided in Rust? (think about composition - use of structs and impl functions) 

## Code Snippet:

ui/mod.rs
```rust
pub enum Screen {
    Loading,
    Main,
    ChooseTeam,
    MainGameScreen,
    RaceScreen { race_id: u16 },
    Leaderboard,
    TeamScreen { team_id: u16 },
    TeamListScreen,
    DriverScreen { driver_id: u16 },
    DriverListScreen,
    RaceScheduleScreen,
}

[...]

pub fn build_ui() -> impl druid::Widget<AppState> {
    ViewSwitcher::new(
        |data: &AppState, _env| (data.current_screen.clone(), data.game_number.clone()),
        |(screen, _game_number), _data, _env| -> Box<dyn druid::Widget<AppState>> {
            fn with_navbar(inner: impl Widget<AppState> + 'static) -> impl Widget<AppState> {
                Flex::column()
                    .with_child(build_navbar())
                    .with_spacer(10.0)
                    .with_flex_child(inner, 1.0)
            }

            match screen {
                Screen::Loading => Box::new(loading_screen::build_screen()),
                Screen::Main => Box::new(main_screen::build_screen()),
                Screen::TeamScreen { team_id } => {
                    Box::new(with_navbar(team_screen::build_screen(team_id)))
                }
                Screen::ChooseTeam => Box::new(choose_team_screen::build_screen()),
                Screen::MainGameScreen => Box::new(with_navbar(main_game_screen::build_screen())),
                Screen::RaceScreen { race_id } => {
                    Box::new(with_navbar(race_screen::build_screen(*race_id)))
                }
                Screen::Leaderboard => Box::new(with_navbar(leaderboard_screen::build_screen())),
                Screen::TeamListScreen => Box::new(with_navbar(team_list_screen::build_screen())),
                Screen::DriverScreen { driver_id } => {
                    Box::new(with_navbar(driver_screen::build_screen(driver_id)))
                }
                Screen::DriverListScreen => {
                    Box::new(with_navbar(driver_list_screen::build_screen()))
                }
                Screen::RaceScheduleScreen => {
                    Box::new(with_navbar(race_schedule_screen::build_screen()))
                }
            }
        },
    )
}
````

ui/leaderboard_screen.rs
```rust
pub fn build_screen() -> impl Widget<AppState> {
    let mut left_column = Flex::column().cross_axis_alignment(CrossAxisAlignment::Start);
    left_column.add_child(Label::new("Top 3 drivers standings").with_text_size(20.0));
    left_column.add_spacer(5.0);
    left_column.add_flex_child(
        SizedBox::new(
            Scroll::new(make_table(
                vec![
                    "#".to_string(),
                    "Driver Name".to_string(),
                    "Points".to_string(),
                ],
                get_top_driver_standings(None),
                vec![(1, goto_driver())],
            ))
            .vertical(),
        )
        .height(500.0),
        1.0,
    );
```


ui/driver_screen.rs
```rust
pub fn build_screen(driver_id: &u16) -> impl Widget<AppState> {
    let driver = get_driver_by_id(driver_id).unwrap();
    let driver_contract = get_driver_contract(driver_id).unwrap();

    let mut right_column = Flex::column().cross_axis_alignment(CrossAxisAlignment::Start);
    right_column.add_child(get_driver(driver.image_path.as_str()));
    right_column.add_child(get_country(
        &get_country_image_path(&driver.country_id).unwrap(),
    ));
```