## Question
Structs and Data Organization: Structs are fundamental for organizing data in Rust. How did you decide when to use structs versus tuples or arrays in your project? Discuss any instances where you used the derive attribute with structs or used impl to add behaviour. 

## Code Snippet:
model/circuit.rs stuct
```rust
pub struct Circuit {
    pub name: String,
    pub country_id: u8,
    pub city: String,
    pub length_km: f32,
    pub lap_amount: u8,
    pub image_path: String,
}
```

database/teams.rs (use of vec)
```rust
pub fn get_top_teams_standings(limit: Option<u8>) -> Vec<Vec<String>> {
    [...]
}
```

util/appdata.rs 
```rust
const CARS: [&str; 10] = [
    "alpine.png",
    "aston_martin.png",
    "ferrari.png",
    "haas.png",
    "kick_sauber.png",
    "mclaren.png",
    "mercedes.png",
    "racing_bulls.png",
    "red_bull_racing.png",
    "williams.png",
];
```



database/teams.rs (use of tuples) get_own_team_standing:
```rust
pub fn get_own_team_standing() -> Option<(String, Vec<String>, u16)> {
    let conn = get_connection().unwrap();
    [...]
}
```

backend/race.rs
```rust
fn calculate_driver_total_times(driver_lap_times: &[(u16, Vec<f32>)]) -> Vec<(u16, f32)> {
    let mut driver_total_times = Vec::new();
    for (driver_id, laps) in driver_lap_times {
        let total_time: f32 = laps.iter().sum();
        driver_total_times.push((*driver_id, total_time));
    }
    driver_total_times.sort_by(|a, b| a.1.partial_cmp(&b.1).unwrap());
    driver_total_times
}
```


database/circuit
```rust
pub fn get_circuit_by_id(circuit_id: &u16) -> Option<Circuit> {
    let conn = get_connection().unwrap();
    let mut stmt = conn.prepare(
        "SELECT name, fk_country_id, city, length_km, lap_amount, image_circuit FROM circuits WHERE id = ?"
    ).unwrap();
    let row = stmt.query_row([circuit_id], |row| {
        Ok(Circuit {
            name: row.get(0)?,
            country_id: row.get(1)?,
            city: row.get(2)?,
            length_km: row.get(3)?,
            lap_amount: row.get(4)?,
            image_path: row.get(5)?,
        })
    });
    match row {
        Ok(circuit) => Some(circuit),
        Err(_) => None,
    }
}

```

The use of derive in ui/mod.rs
```rust
#[derive(Clone, Data, Lens)]
pub struct AppState {
    pub current_screen: Screen,
    pub game_number: String,
    pub selected_team: Option<String>,
    pub current_date: String,
    pub last_race_update_time: String,
    pub show_modal: bool,
}

#[derive(Clone, PartialEq, Eq, Data)]
pub enum Screen {
    Loading,
    Main,
    ChooseTeam,
    MainGameScreen,
    RaceScreen { race_id: u16 },
    Leaderboard,
    TeamScreen { team_id: u16 },
    TeamListScreen,
    DriverScreen { driver_id: u16 },
    DriverListScreen,
    RaceScheduleScreen,
}

impl Default for AppState {
    fn default() -> Self {
        AppState {
            current_screen: Screen::Loading,
            game_number: String::new(),
            selected_team: None,
            show_modal: false,
            current_date: NaiveDate::from_ymd_opt(2025, 1, 1).unwrap().to_string(),
            last_race_update_time: Utc::now().to_string(),
        }
    }
}
```